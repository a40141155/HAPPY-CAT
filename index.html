<!-- Firebase 即時同步：跨裝置自動更新目前正在上台/下一家 -->
<script type="module">
  // 1) 先替換成你的 Firebase 專案設定
  const firebaseConfig = {
    apiKey: "YOUR_API_KEY",
    authDomain: "YOUR_PROJECT.firebaseapp.com",
    databaseURL: "https://YOUR_PROJECT-default-rtdb.firebaseio.com",
    projectId: "YOUR_PROJECT",
    storageBucket: "YOUR_PROJECT.appspot.com",
    messagingSenderId: "YOUR_SENDER_ID",
    appId: "YOUR_APP_ID"
  };

  // 2) 初始化
  import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-app.js";
  import { getDatabase, ref, onValue, set, serverTimestamp } from "https://www.gstatic.com/firebasejs/10.12.2/firebase-database.js";
  const app = initializeApp(firebaseConfig);
  const db = getDatabase(app);

  // ===== 綁到你現有的變數／函式 =====
  // 這三個是你原檔案裡面已存在的全域函式／變數（若不在全域，請移到全域）
  // currentDay (1|2), currentIdx (Number), renderLive() 會把 UI 重新渲染
  // getList() 取得當前日程清單

  // 3) 設定資料路徑（可改成活動代碼）
  const stateRef = ref(db, "mgs/live-state"); // e.g. mgs-2025/track-a

  // 4) 讀：任何人開啟頁面，都即時跟隨 DB 狀態
  let suppressWrite = false; // 避免讀回時又觸發寫入循環
  onValue(stateRef, (snap) => {
    const val = snap.val();
    if (!val) return;
    suppressWrite = true;
    currentDay = (val.day === 2) ? 2 : 1;
    currentIdx = Math.max(0, parseInt(val.idx || 0, 10));
    renderLive();
    suppressWrite = false;
  });

  // 5) 寫：只有主持台在按鈕時寫入 DB，其他裝置自動跟上
  async function writeState() {
    if (suppressWrite) return;
    await set(stateRef, {
      day: currentDay,
      idx: currentIdx,
      updatedAt: serverTimestamp()
    });
  }

  // 6) 取代你原本對 hash 的 write：把這三處綁寫 DB
  //    - 切換日程
  document.querySelector('[data-list="day1"]')?.addEventListener('click', () => { currentDay = 1; currentIdx = 0; renderLive(); writeState(); });
  document.querySelector('[data-list="day2"]')?.addEventListener('click', () => { currentDay = 2; currentIdx = 0; renderLive(); writeState(); });
  //    - 上一家／下一家
  document.getElementById('live-prev')?.addEventListener('click', () => {
    if (currentIdx > 0) { currentIdx--; renderLive(); writeState(); }
  });
  document.getElementById('live-next')?.addEventListener('click', () => {
    const list = getList();
    if (currentIdx < list.length - 1) { currentIdx++; renderLive(); writeState(); }
  });
  //    - 鍵盤 ← / →
  window.addEventListener('keydown', (e) => {
    if(!document.getElementById('live').classList.contains('active')) return;
    if(e.key === 'ArrowLeft'){ const b=document.getElementById('live-prev'); b && b.click(); }
    if(e.key === 'ArrowRight'){ const b=document.getElementById('live-next'); b && b.click(); }
  });
</script>
